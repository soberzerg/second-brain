# Руководство по безопасной разработке

**Проект:** Dogovor24
**Версия:** 1.0
**Дата:** 5 января 2026
**Автор:** Сергей Соболев (Технический консультант по безопасности)

---

## Оглавление

1. [Краткий Security Checklist](#краткий-security-checklist)
2. [OWASP Top 10 для Laravel/PHP](#owasp-top-10-для-laravelphp)
3. [Laravel Security Best Practices](#laravel-security-best-practices)
4. [Code Review Guidelines](#code-review-guidelines)
5. [Quick Wins & Action Items](#quick-wins--action-items)

---

## Краткий Security Checklist

### Top-10 правил безопасности

#### ✅ DO

1. **Используйте Laravel Policies/Gates** для проверки прав доступа к ресурсам
2. **Валидируйте все user input** через Form Requests с явными правилами
3. **Используйте Eloquent ORM или Query Builder** с параметризацией для SQL
4. **Логируйте security-события:** отказы в доступе, подозрительную активность
5. **Используйте `bcrypt()` или `Hash::make()`** для хеширования паролей
6. **Валидируйте MIME-тип и размер** при загрузке файлов
7. **Используйте `composer install`** в deploy.sh (НЕ `composer update`)
8. **Запускайте `composer audit`** регулярно для проверки уязвимостей
9. **Экранируйте вывод в Blade** через `{{ $var }}` (не `{!! $var !!}`)
10. **Храните секреты в `.env`** (НИКОГДА не коммитьте реальные ключи в `.env.example`)

#### ❌ DON'T

1. **НЕ используйте прямые SQL запросы** с конкатенацией пользовательского ввода
2. **НЕ используйте `crypt()`** с статической солью для криптографии
3. **НЕ пропускайте авторизацию** в контроллерах (IDOR уязвимость)
4. **НЕ загружайте весь файл в память** для проверки размера (`strlen()`)
5. **НЕ парсите XML** без отключения внешних сущностей (XXE)
6. **НЕ коммитьте hardcoded ключи, пароли, токены** в код
7. **НЕ используйте устаревшие зависимости** (регулярно обновляйте)
8. **НЕ игнорируйте `AuthorizationException`** - логируйте отказы в доступе
9. **НЕ используйте `{!! $var !!}`** без явной необходимости (XSS риск)
10. **НЕ храните файлы в webroot** - используйте `storage/` с ограниченным доступом

### PR Security Checklist

При code review каждого pull request проверяйте:

- [ ] **SQL Security:** Нет прямых SQL запросов с конкатенацией user input
- [ ] **Input Validation:** Все user input валидируется через Form Requests
- [ ] **Authorization:** Проверка прав доступа для всех операций с ресурсами
- [ ] **File Upload:** Валидация MIME-типа и размера файлов
- [ ] **Secrets Management:** Нет hardcoded секретов, ключей, паролей в коде
- [ ] **Dependencies:** Новые зависимости проверены на уязвимости (`composer audit`)
- [ ] **Security Logging:** Security-критичные действия логируются
- [ ] **XML/JSON Parsing:** Безопасные настройки парсинга (отключены внешние сущности)
- [ ] **Cryptography:** Современные алгоритмы (bcrypt/Hash, НЕ crypt с static salt)
- [ ] **Environment Files:** `.env.example` не содержит реальных секретов

### Laravel Security Quick Reference

| Задача | Безопасный подход | Небезопасный подход |
|--------|-------------------|---------------------|
| Хеширование паролей | `Hash::make($password)`, `bcrypt($password)` | `crypt($password, 'static_salt')`, `md5()` |
| SQL запросы | `DB::table('users')->where('id', $id)`, Eloquent | `DB::raw("SELECT * FROM users WHERE id = $id")` |
| Авторизация | `$this->authorize('view', $file)`, Policies | Без проверки доступа |
| Валидация input | Form Requests с правилами | Без валидации или `request()->all()` |
| Вывод в Blade | `{{ $var }}` (auto-escape) | `{!! $var !!}` (no escape) |
| Загрузка файлов | `mimes:pdf,docx|max:10240` | `file|max:20480` (без MIME) |
| Парсинг XML | `libxml_disable_entity_loader(true)` | `new SimpleXMLElement($xml)` |
| Deploy зависимостей | `composer install --no-dev` | `composer update` |

---

## OWASP Top 10 для Laravel/PHP

### A01:2021 – Broken Access Control (IDOR)

**Описание:** Insecure Direct Object Reference (IDOR) - доступ к ресурсам без проверки прав пользователя.

#### Найденные уязвимости в explorer-service

1. **IDOR при скачивании файла** (`UUIDFileController::download`)
2. **IDOR при просмотре метаданных** (`UUIDFileController::show`)

#### Уязвимый код

```php
// app/Http/Controllers/UUIDFileController.php
public function download(string $uuid)
{
    // ❌ Нет проверки прав доступа!
    return $this->uuidFileService->download($uuid);
}

public function show(string $uuid)
{
    $file = File::where('uuid', $uuid)->firstOrFail();

    // ❌ Проверяется только workspace, но не права пользователя на файл
    if ($file->workspace_id !== auth()->user()->current_workspace_id) {
        abort(403);
    }

    return new FileResource($file);
}
```

**Сценарий атаки:**
- Атакующий узнает UUID чужого файла (из логов, перебором, утечки)
- Отправляет GET `/api/explorer/uuid-file/{target_uuid}/download`
- Получает конфиденциальный файл без авторизации

#### Безопасное решение

**Вариант 1: Laravel Policy (рекомендуется)**

```php
// app/Policies/FilePolicy.php
namespace App\Policies;

use App\Models\File;
use App\Models\User;

class FilePolicy
{
    public function view(User $user, File $file): bool
    {
        // Проверяем, что пользователь имеет доступ к файлу
        return $file->workspace_id === $user->current_workspace_id
            && ($file->user_id === $user->id || $this->hasSharedAccess($user, $file));
    }

    public function download(User $user, File $file): bool
    {
        return $this->view($user, $file);
    }

    private function hasSharedAccess(User $user, File $file): bool
    {
        // Проверка shared access через pivot таблицу
        return $file->sharedUsers()->where('user_id', $user->id)->exists();
    }
}

// app/Http/Controllers/UUIDFileController.php
public function download(File $file)  // Route model binding
{
    // ✅ Явная проверка авторизации через Policy
    $this->authorize('download', $file);

    return $this->uuidFileService->download($file);
}

public function show(File $file)
{
    // ✅ Проверка прав доступа
    $this->authorize('view', $file);

    return new FileResource($file);
}
```

**Вариант 2: Gate для сложной логики**

```php
// app/Providers/AuthServiceProvider.php
use Illuminate\Support\Facades\Gate;

public function boot()
{
    Gate::define('download-file', function (User $user, File $file) {
        return $file->workspace_id === $user->current_workspace_id
            && ($file->user_id === $user->id || $file->sharedUsers->contains($user));
    });
}

// Контроллер
public function download(File $file)
{
    if (Gate::denies('download-file', $file)) {
        abort(403, 'Unauthorized to download this file');
    }

    return $this->uuidFileService->download($file);
}
```

**Вариант 3: Middleware для защиты роутов**

```php
// routes/api.php
Route::middleware(['auth:sanctum', 'can:download,file'])->group(function () {
    Route::get('/uuid-file/{file}/download', [UUIDFileController::class, 'download']);
    Route::get('/uuid-file/{file}', [UUIDFileController::class, 'show']);
});
```

#### Best Practices

1. **Всегда используйте авторизацию** для доступа к ресурсам
2. **Используйте Policies для моделей** - централизованная логика доступа
3. **Route Model Binding** с проверкой через middleware `can:`
4. **Global Scopes** для автоматической фильтрации по workspace/tenant
5. **Логируйте отказы в доступе** для обнаружения атак

---

### A02:2021 – Cryptographic Failures

**Описание:** Использование слабой криптографии, статических солей, хранение секретов в коде.

#### Найденные уязвимости в explorer-service

1. **Слабая криптография со статической солью** (`crypt('d24')` в QrService)
2. **Жестко заданный ключ шифрования** в `.env.example`

#### Уязвимый код

```php
// app/Services/QR/NoAuth/QrService.php
public function generateNoAuthLink($workspaceId, $fileSignatureId): string
{
    // ❌ Использование crypt() со статической солью 'd24'
    $encrypted = crypt("{$workspaceId}:{$fileSignatureId}", 'd24');

    $hash = hash('sha256', $encrypted . config('app.key'));

    return route('qr.no-auth', [
        'encrypted' => $encrypted,
        'hash' => $hash,
    ]);
}

public function validateHash(string $encrypted, string $hash): bool
{
    // ❌ Проверка опирается на слабое шифрование
    $expectedHash = hash('sha256', $encrypted . config('app.key'));

    return hash_equals($expectedHash, $hash);
}
```

```bash
# .env.example
# ❌ Жестко заданный ключ шифрования
FILE_ENCRYPTION_KEY=w9VDvenKYpdcRAfrAh0IKSmRJW1JYii4
```

**Сценарий атаки:**
- Атакующий знает, что используется `crypt(..., 'd24')`
- Генерирует `encrypted` для любых `workspace_id:file_signature_id`
- Вычисляет корректный `hash` и получает доступ к подписанию без аутентификации

#### Безопасное решение

```php
// app/Services/QR/NoAuth/QrService.php
use Illuminate\Support\Facades\Crypt;

public function generateNoAuthLink($workspaceId, $fileSignatureId): string
{
    // ✅ Используем Laravel Encryption (AES-256-CBC)
    $payload = json_encode([
        'workspace_id' => $workspaceId,
        'file_signature_id' => $fileSignatureId,
        'expires_at' => now()->addHours(24)->timestamp, // Ограничение по времени
    ]);

    $encrypted = Crypt::encryptString($payload);

    // ✅ HMAC для контроля целостности
    $signature = hash_hmac('sha256', $encrypted, config('app.key'));

    return route('qr.no-auth', [
        'token' => base64_encode($encrypted),
        'signature' => $signature,
    ]);
}

public function validateAndDecrypt(string $token, string $signature): ?array
{
    try {
        $encrypted = base64_decode($token);

        // ✅ Проверка HMAC signature
        $expectedSignature = hash_hmac('sha256', $encrypted, config('app.key'));

        if (!hash_equals($expectedSignature, $signature)) {
            return null; // Подделка данных
        }

        // ✅ Расшифровка
        $decrypted = Crypt::decryptString($encrypted);
        $payload = json_decode($decrypted, true);

        // ✅ Проверка срока действия
        if ($payload['expires_at'] < now()->timestamp) {
            return null; // Токен истек
        }

        return $payload;

    } catch (\Exception $e) {
        \Log::warning('Failed to decrypt NoAuth token', ['error' => $e->getMessage()]);
        return null;
    }
}
```

**Управление секретами**

```bash
# .env (НИКОГДА не коммитить!)
APP_KEY=base64:RealSecretKeyGeneratedByArtisan
FILE_ENCRYPTION_KEY=base64:AnotherRealSecretKey

# .env.example (безопасный пример)
# ✅ Не содержит реальных ключей
APP_KEY=
FILE_ENCRYPTION_KEY=

# Инструкция для генерации
# php artisan key:generate
# php artisan key:generate --show  # для FILE_ENCRYPTION_KEY
```

#### Best Practices

1. **Используйте Laravel Encryption** (`Crypt::encrypt/decrypt`) для AES-256
2. **Генерируйте APP_KEY** через `php artisan key:generate`
3. **Ротация ключей:** планируйте регулярную смену критичных ключей
4. **HMAC для integrity:** используйте `hash_hmac()` для проверки целостности
5. **Не используйте устаревшие функции:** `crypt()`, `md5()`, `sha1()` для паролей
6. **Используйте `bcrypt()` или `Hash::make()`** для хеширования паролей

---

### A03:2021 – Injection (SQL, XXE)

**Описание:** SQL-инъекции, XXE (XML External Entity), команды инъекции.

#### A03.1: SQL Injection

##### Найденная уязвимость в explorer-service

**SQL-инъекция в PrepareDownloadMultipleJob** - критическая уязвимость с конкатенацией user input.

##### Уязвимый код

```php
// app/Jobs/PrepareDownloadMultipleJob.php
public function handle()
{
    $fileUuids = $this->data['file_uuids']; // Массив из пользовательского ввода

    // ❌ Прямая конкатенация в SQL запрос
    $files = DB::select("
        SELECT * FROM files
        WHERE uuid IN ('" . implode("','", $fileUuids) . "')
        AND workspace_id = ?
    ", [$this->workspaceId]);

    // ... обработка файлов
}

// app/Http/Requests/PrepareDownloadMultipleRequest.php
public function rules(): array
{
    return [
        'file_uuids' => 'required|array', // ❌ Нет валидации элементов!
        'mode' => 'required|in:zip,pdf',
    ];
}
```

**Сценарий атаки:**
```json
POST /api/download-multiple
{
  "file_uuids": ["') UNION SELECT password FROM users WHERE '1'='1"],
  "mode": "zip"
}
```

**Результат:** SQL запрос становится:
```sql
SELECT * FROM files
WHERE uuid IN ('') UNION SELECT password FROM users WHERE '1'='1')
AND workspace_id = 1
```

##### Безопасное решение

**Вариант 1: Eloquent ORM (рекомендуется)**

```php
// app/Jobs/PrepareDownloadMultipleJob.php
public function handle()
{
    $fileUuids = $this->data['file_uuids'];

    // ✅ Eloquent автоматически параметризует запрос
    $files = File::query()
        ->whereIn('uuid', $fileUuids)
        ->where('workspace_id', $this->workspaceId)
        ->get();

    // ... обработка файлов
}

// app/Http/Requests/PrepareDownloadMultipleRequest.php
public function rules(): array
{
    return [
        'file_uuids' => 'required|array',
        'file_uuids.*' => 'required|uuid', // ✅ Валидация каждого элемента как UUID
        'mode' => 'required|in:zip,pdf',
    ];
}
```

**Вариант 2: Query Builder с параметризацией**

```php
use Illuminate\Support\Facades\DB;

public function handle()
{
    $fileUuids = $this->data['file_uuids'];

    // ✅ Query Builder с parameter binding
    $files = DB::table('files')
        ->whereIn('uuid', $fileUuids)
        ->where('workspace_id', $this->workspaceId)
        ->get();
}
```

**Вариант 3: Если необходим Raw SQL**

```php
// Только в крайних случаях!
public function handle()
{
    $fileUuids = $this->data['file_uuids'];

    // ✅ Создаем placeholders для параметризации
    $placeholders = implode(',', array_fill(0, count($fileUuids), '?'));

    $files = DB::select("
        SELECT * FROM files
        WHERE uuid IN ($placeholders)
        AND workspace_id = ?
    ", array_merge($fileUuids, [$this->workspaceId]));
}
```

#### A03.2: XXE Injection (XML External Entity)

##### Найденная уязвимость в explorer-service

**XXE в парсинге XML подписей** - позволяет читать локальные файлы и выполнять SSRF.

##### Уязвимый код

```php
// app/Http/Controllers/FileSignatureController.php
public function update(UpdateFileSignatureRequest $request, FileSignature $signature)
{
    $signatureXml = $request->input('signature');

    // ❌ Парсинг XML без отключения внешних сущностей
    $xml = new \SimpleXMLElement($signatureXml);

    // ... обработка XML
}

// app/Services/UUIDFileService.php
public function getSignatureContent(File $file): string
{
    $signatureXml = $file->signature->content;

    // ❌ Небезопасный парсинг сохраненного XML
    $xml = new \SimpleXMLElement($signatureXml);

    return (string) $xml->SignatureValue;
}
```

**Payload атаки:**
```xml
<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<signature>
  <value>&xxe;</value>
</signature>
```

##### Безопасное решение

```php
// app/Http/Controllers/FileSignatureController.php
public function update(UpdateFileSignatureRequest $request, FileSignature $signature)
{
    $signatureXml = $request->input('signature');

    // ✅ Отключение внешних сущностей ПЕРЕД парсингом
    $previousValue = libxml_disable_entity_loader(true);

    try {
        // ✅ Дополнительные защитные флаги
        libxml_use_internal_errors(true);

        $xml = new \SimpleXMLElement(
            $signatureXml,
            LIBXML_NOENT | LIBXML_DTDLOAD | LIBXML_DTDATTR
        );

        // ... обработка XML

    } catch (\Exception $e) {
        \Log::warning('Failed to parse signature XML', [
            'error' => $e->getMessage(),
            'user_id' => auth()->id(),
        ]);

        abort(400, 'Invalid signature XML format');

    } finally {
        // ✅ Восстановление предыдущего значения
        libxml_disable_entity_loader($previousValue);
        libxml_use_internal_errors(false);
    }
}
```

**Альтернатива: DOMDocument (более безопасный)**

```php
public function parseSignatureXml(string $xml): array
{
    libxml_use_internal_errors(true);

    $dom = new \DOMDocument();

    // ✅ Отключение загрузки внешних сущностей
    $dom->substituteEntities = false;
    $dom->resolveExternals = false;

    if (!$dom->loadXML($xml, LIBXML_NOENT | LIBXML_DTDLOAD)) {
        throw new \InvalidArgumentException('Invalid XML');
    }

    // Обработка через DOMDocument
    return [
        'value' => $dom->getElementsByTagName('value')->item(0)->nodeValue,
    ];
}
```

#### Best Practices

**SQL Injection Prevention:**
1. **Всегда используйте Eloquent ORM** или Query Builder
2. **Параметризуйте запросы** - никогда не конкатенируйте user input
3. **Валидируйте массивы** с использованием `array.*` правил
4. **Используйте UUID/INT валидацию** для идентификаторов
5. **Избегайте `DB::raw()`** без крайней необходимости

**XXE Prevention:**
1. **Всегда отключайте внешние сущности** перед парсингом XML
2. **Используйте `libxml_disable_entity_loader(true)`**
3. **Предпочитайте DOMDocument** вместо SimpleXMLElement
4. **Валидируйте XML через XSD schema** если возможно
5. **Логируйте попытки парсинга** с некорректным XML

---

### A04:2021 – Insecure Design

**Описание:** Архитектурные проблемы безопасности, DoS уязвимости, отсутствие rate limiting.

#### Найденные уязвимости в explorer-service

1. **Исчерпание памяти при проверке размера файла** (`strlen()` на всем файле)
2. **Неограниченная загрузка файлов** (нет MIME validation)

#### A04.1: Memory Exhaustion (DoS)

##### Уязвимый код

```php
// app/Http/Requests/AttachDocumentRequest.php
protected function passedValidation()
{
    $path = $this->file('document')->store('temp');

    // ❌ Загрузка всего файла в память для подсчета размера
    $size = strlen(EncryptedStorageService::get($path));

    if ($size > $this->maxFileSize()) {
        Storage::delete($path);
        throw ValidationException::withMessages([
            'document' => 'File size exceeds limit',
        ]);
    }
}
```

**Сценарий атаки:**
- Атакующий загружает файл 1GB
- `EncryptedStorageService::get()` загружает весь файл в память
- PHP процесс падает с OOM (Out Of Memory)
- Повторяющиеся запросы = DoS

##### Безопасное решение

```php
// app/Http/Requests/AttachDocumentRequest.php
use Illuminate\Support\Facades\Storage;

protected function passedValidation()
{
    $uploadedFile = $this->file('document');

    // ✅ Получение размера из метаданных файла (без загрузки в память)
    $size = $uploadedFile->getSize();

    if ($size > $this->maxFileSize()) {
        throw ValidationException::withMessages([
            'document' => "File size ({$this->formatBytes($size)}) exceeds limit ({$this->formatBytes($this->maxFileSize())})",
        ]);
    }

    // Сохранение только после валидации
    $path = $uploadedFile->store('documents', 'encrypted');

    // ✅ Проверка размера в storage (если нужна дополнительная проверка)
    $storedSize = Storage::disk('encrypted')->size($path);

    if ($storedSize > $this->maxFileSize()) {
        Storage::disk('encrypted')->delete($path);
        throw ValidationException::withMessages([
            'document' => 'Stored file size validation failed',
        ]);
    }
}

private function formatBytes(int $bytes): string
{
    return number_format($bytes / 1024 / 1024, 2) . ' MB';
}

private function maxFileSize(): int
{
    return 20 * 1024 * 1024; // 20 MB
}
```

**Stream-based обработка для больших файлов**

```php
// Если необходимо обработать содержимое файла
use Illuminate\Support\Facades\Storage;

public function processLargeFile(string $path): void
{
    $stream = Storage::disk('encrypted')->readStream($path);

    if (!$stream) {
        throw new \RuntimeException('Failed to open file stream');
    }

    try {
        // ✅ Обработка по chunk'ам, а не весь файл в память
        while (!feof($stream)) {
            $chunk = fread($stream, 8192); // 8KB chunks

            // Обработка chunk
            $this->processChunk($chunk);
        }
    } finally {
        fclose($stream);
    }
}
```

#### A04.2: Unrestricted File Upload

##### Уязвимый код

```php
// app/Http/Requests/StoreFileRequest.php
public function rules(): array
{
    return [
        'file' => 'file|max:20480', // ❌ Нет валидации MIME-типа!
    ];
}

// app/Http/Requests/File1C/StoreFile1cRequest.php
public function rules(): array
{
    return [
        'file' => 'required|file|max:20480', // ❌ Разрешены любые типы
    ];
}
```

**Риски:**
1. **Stored XSS** через загрузку HTML/SVG файлов
2. **RCE** через эксплуатацию уязвимостей в Unoconv/LibreOffice при конвертации
3. **Malware distribution** через платформу

##### Безопасное решение

```php
// app/Http/Requests/StoreFileRequest.php
public function rules(): array
{
    return [
        'file' => [
            'required',
            'file',
            'max:20480', // 20MB
            // ✅ Белый список MIME-типов
            'mimes:pdf,doc,docx,xls,xlsx,txt,jpg,jpeg,png',
        ],
    ];
}

// Для более строгой проверки
public function rules(): array
{
    return [
        'file' => [
            'required',
            'file',
            'max:20480',
            Rule::mimetypes([
                'application/pdf',
                'application/msword',
                'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                'application/vnd.ms-excel',
                'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                'text/plain',
                'image/jpeg',
                'image/png',
            ]),
        ],
    ];
}
```

**Дополнительная валидация с проверкой содержимого**

```php
// app/Http/Requests/StoreFileRequest.php
use Illuminate\Validation\Rules\File;

public function rules(): array
{
    return [
        'file' => [
            'required',
            File::types(['pdf', 'docx', 'xlsx', 'jpg', 'png'])
                ->max(20 * 1024), // 20MB
        ],
    ];
}

protected function passedValidation()
{
    $file = $this->file('file');

    // ✅ Проверка реального MIME-типа (не только extension)
    $mimeType = $file->getMimeType();
    $allowedMimes = [
        'application/pdf',
        'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'image/jpeg',
        'image/png',
    ];

    if (!in_array($mimeType, $allowedMimes)) {
        throw ValidationException::withMessages([
            'file' => "File type {$mimeType} is not allowed",
        ]);
    }

    // ✅ Дополнительная проверка через fileinfo
    $finfo = finfo_open(FILEINFO_MIME_TYPE);
    $detectedMime = finfo_file($finfo, $file->getRealPath());
    finfo_close($finfo);

    if ($detectedMime !== $mimeType) {
        \Log::warning('MIME type mismatch', [
            'uploaded_mime' => $mimeType,
            'detected_mime' => $detectedMime,
            'user_id' => auth()->id(),
        ]);

        throw ValidationException::withMessages([
            'file' => 'File type validation failed',
        ]);
    }
}
```

**Безопасное хранение загруженных файлов**

```php
// config/filesystems.php
'disks' => [
    'uploads' => [
        'driver' => 'local',
        'root' => storage_path('app/uploads'), // ✅ Вне webroot
        'visibility' => 'private', // ✅ Не публичный доступ
    ],
],

// Controller
public function store(StoreFileRequest $request)
{
    $file = $request->file('file');

    // ✅ Генерация безопасного имени файла
    $filename = Str::uuid() . '.' . $file->getClientOriginalExtension();

    // ✅ Хранение в приватном storage
    $path = $file->storeAs('documents', $filename, 'uploads');

    // ✅ Сохранение метаданных в БД
    $uploadedFile = File::create([
        'uuid' => Str::uuid(),
        'original_name' => $file->getClientOriginalName(),
        'stored_name' => $filename,
        'path' => $path,
        'mime_type' => $file->getMimeType(),
        'size' => $file->getSize(),
        'user_id' => auth()->id(),
        'workspace_id' => auth()->user()->current_workspace_id,
    ]);

    return new FileResource($uploadedFile);
}

// Скачивание через контроллер (а не прямой доступ)
public function download(File $file)
{
    $this->authorize('download', $file);

    // ✅ Content-Disposition: attachment для предотвращения XSS
    return Storage::disk('uploads')->download(
        $file->path,
        $file->original_name,
        ['Content-Type' => 'application/octet-stream']
    );
}
```

#### Best Practices

1. **Stream-based processing** для больших файлов
2. **MIME-type whitelist** для загрузки файлов
3. **Проверка реального MIME** (не только extension)
4. **Хранение вне webroot** в private storage
5. **Content-Disposition: attachment** при скачивании
6. **Rate limiting** для endpoints загрузки
7. **Virus scanning** для критичных систем (ClamAV)

---

### A06:2021 – Vulnerable and Outdated Components

**Описание:** Использование устаревших зависимостей с известными уязвимостями.

#### Найденные уязвимости в explorer-service

1. **Устаревшие зависимости с CVE**
   - `lcobucci/jwt` 3.4.4 (уязвим к CVE-2021-21245 - обход проверки подписи)
   - `guzzlehttp/guzzle` 6.5.5 (уязвим к CVE-2022-31090)

2. **Небезопасное обновление зависимостей** в `deploy.sh`

#### A06.1: Outdated Dependencies

##### Проверка уязвимостей

```bash
# ✅ Регулярно запускайте composer audit
composer audit

# Вывод:
# Package: lcobucci/jwt
# Version: 3.4.4
# Advisory: Improper Signature Verification (CVE-2021-21245)
# Fix: Upgrade to >= 3.4.6
```

##### Безопасное обновление

```bash
# Обновление конкретной зависимости
composer require lcobucci/jwt:^4.0

# Обновление всех minor/patch версий
composer update

# После обновления - тестирование
php artisan test
```

**composer.json с фиксацией версий**

```json
{
    "require": {
        "php": "^8.1",
        "laravel/framework": "^10.0",
        "lcobucci/jwt": "^4.3",  // ✅ Минимум 4.3 (исправлен CVE)
        "guzzlehttp/guzzle": "^7.5"  // ✅ Обновлено до 7.x
    }
}
```

#### A06.2: Insecure Deployment (composer update)

##### Уязвимый deploy.sh

```bash
#!/bin/bash

# ❌ КРИТИЧЕСКАЯ УЯЗВИМОСТЬ
composer update

php artisan migrate --force
php artisan config:cache
php artisan route:cache
php artisan view:cache
```

**Проблема:**
- `composer update` игнорирует `composer.lock`
- Устанавливает последние версии (могут быть вредоносными или несовместимыми)
- Риск supply chain attack

##### Безопасный deploy.sh

```bash
#!/bin/bash
set -e  # Exit on error

echo "Starting deployment..."

# ✅ БЕЗОПАСНО: используем composer install с lock-файлом
composer install \
    --no-dev \
    --no-interaction \
    --prefer-dist \
    --optimize-autoloader

# Clear caches
php artisan cache:clear
php artisan config:clear
php artisan route:clear
php artisan view:clear

# Run migrations
php artisan migrate --force

# Rebuild caches
php artisan config:cache
php artisan route:cache
php artisan view:cache

# Restart queue workers if using queues
php artisan queue:restart

echo "Deployment completed successfully!"
```

**CI/CD Pipeline с проверкой уязвимостей**

```yaml
# .gitlab-ci.yml / .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [main]

jobs:
  security-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.1'

      # ✅ Проверка уязвимостей ПЕРЕД деплоем
      - name: Install dependencies
        run: composer install --no-dev

      - name: Security audit
        run: composer audit

      - name: Run tests
        run: php artisan test

  deploy:
    needs: security-check
    runs-on: ubuntu-latest
    steps:
      # ... deploy steps
```

#### Best Practices

1. **Регулярно обновляйте зависимости** (weekly/monthly)
2. **Запускайте `composer audit`** в CI/CD
3. **Используйте `composer install` в продакшене** (НЕ update)
4. **Коммитьте `composer.lock`** в git
5. **Мониторьте security advisories** (GitHub Dependabot, Snyk)
6. **Тестируйте обновления** перед продакшеном (staging environment)
7. **Фиксируйте версии критичных зависимостей** в composer.json

---

### A09:2021 – Security Logging and Monitoring Failures

**Описание:** Отсутствие логирования security-событий, невозможность обнаружения атак.

#### Найденная уязвимость в explorer-service

**Отсутствие логирования отказов в авторизации** - `AuthorizationException` не логируется.

#### Уязвимый код

```php
// app/Exceptions/Handler.php
namespace App\Exceptions;

use Illuminate\Foundation\Exceptions\Handler as ExceptionHandler;

class Handler extends ExceptionHandler
{
    protected $dontReport = [
        // ❌ По умолчанию Laravel не логирует AuthorizationException
    ];

    public function report(Throwable $exception)
    {
        parent::report($exception); // Фильтрует AuthorizationException
    }
}
```

**Проблема:**
- Атакующий пытается получить доступ к чужим файлам
- Получает 403 Forbidden
- **Событие не логируется** - security team не видит атаку
- Невозможность обнаружить IDOR brute-force

#### Безопасное решение

```php
// app/Exceptions/Handler.php
namespace App\Exceptions;

use Illuminate\Auth\Access\AuthorizationException;
use Illuminate\Foundation\Exceptions\Handler as ExceptionHandler;
use Illuminate\Support\Facades\Log;
use Throwable;

class Handler extends ExceptionHandler
{
    // ✅ Удаляем AuthorizationException из списка игнорируемых
    protected $dontReport = [
        // AuthorizationException больше не игнорируется
    ];

    public function report(Throwable $exception)
    {
        // ✅ Явное логирование отказов в авторизации
        if ($exception instanceof AuthorizationException) {
            $this->reportAuthorizationFailure($exception);
        }

        parent::report($exception);
    }

    protected function reportAuthorizationFailure(AuthorizationException $exception)
    {
        // ✅ Логирование с контекстом для SIEM/мониторинга
        Log::warning('Authorization failed', [
            'exception' => get_class($exception),
            'message' => $exception->getMessage(),
            'user_id' => auth()->id(),
            'user_email' => auth()->user()?->email,
            'ip' => request()->ip(),
            'user_agent' => request()->userAgent(),
            'url' => request()->fullUrl(),
            'method' => request()->method(),
            'referer' => request()->header('referer'),
            'timestamp' => now()->toIso8601String(),
        ]);

        // ✅ Отправка критичных событий в Sentry с тегами
        if (app()->bound('sentry')) {
            app('sentry')->captureException($exception, [
                'level' => 'warning',
                'tags' => [
                    'security' => 'authorization_failure',
                    'user_id' => auth()->id(),
                ],
            ]);
        }
    }
}
```

**Расширенное логирование security-событий**

```php
// app/Services/SecurityLogger.php
namespace App\Services;

use Illuminate\Support\Facades\Log;

class SecurityLogger
{
    public static function logAuthorizationFailure(
        string $resource,
        string $action,
        ?int $userId = null
    ): void {
        Log::channel('security')->warning('Authorization failure', [
            'event_type' => 'authorization_failure',
            'resource' => $resource,
            'action' => $action,
            'user_id' => $userId ?? auth()->id(),
            'ip' => request()->ip(),
            'url' => request()->fullUrl(),
            'timestamp' => now()->toIso8601String(),
        ]);
    }

    public static function logSuspiciousActivity(
        string $activity,
        array $context = []
    ): void {
        Log::channel('security')->warning('Suspicious activity detected', array_merge([
            'event_type' => 'suspicious_activity',
            'activity' => $activity,
            'user_id' => auth()->id(),
            'ip' => request()->ip(),
            'timestamp' => now()->toIso8601String(),
        ], $context));

        // Отправка в Sentry для критичных событий
        if (app()->bound('sentry')) {
            \Sentry\captureMessage("Suspicious activity: {$activity}", [
                'level' => 'warning',
                'tags' => ['security' => 'suspicious_activity'],
                'extra' => $context,
            ]);
        }
    }

    public static function logSQLInjectionAttempt(string $query, array $bindings = []): void
    {
        Log::channel('security')->error('Potential SQL injection attempt', [
            'event_type' => 'sql_injection_attempt',
            'query' => $query,
            'bindings' => $bindings,
            'user_id' => auth()->id(),
            'ip' => request()->ip(),
            'url' => request()->fullUrl(),
            'timestamp' => now()->toIso8601String(),
        ]);

        // Немедленная отправка в Sentry
        \Sentry\captureMessage('SQL Injection Attempt Detected', [
            'level' => 'error',
            'tags' => ['security' => 'sql_injection'],
        ]);
    }

    public static function logFileAccessAttempt(
        string $fileUuid,
        bool $granted
    ): void {
        Log::channel('security')->info('File access attempt', [
            'event_type' => 'file_access',
            'file_uuid' => $fileUuid,
            'access_granted' => $granted,
            'user_id' => auth()->id(),
            'ip' => request()->ip(),
            'timestamp' => now()->toIso8601String(),
        ]);
    }
}

// Использование в контроллере
public function download(File $file)
{
    try {
        $this->authorize('download', $file);

        // ✅ Логирование успешного доступа
        SecurityLogger::logFileAccessAttempt($file->uuid, true);

        return $this->uuidFileService->download($file);

    } catch (AuthorizationException $e) {
        // ✅ Логирование отказа
        SecurityLogger::logFileAccessAttempt($file->uuid, false);
        SecurityLogger::logAuthorizationFailure(File::class, 'download', auth()->id());

        throw $e;
    }
}
```

**Конфигурация отдельного канала для security логов**

```php
// config/logging.php
'channels' => [
    'security' => [
        'driver' => 'daily',
        'path' => storage_path('logs/security.log'),
        'level' => 'info',
        'days' => 90, // Хранить 90 дней для аудита
    ],

    'sentry' => [
        'driver' => 'sentry',
        'level' => 'warning',
    ],
],
```

#### Что логировать (Security Events Checklist)

**Обязательно:**
- [ ] Отказы в авторизации (`AuthorizationException`)
- [ ] Неудачные попытки аутентификации
- [ ] Попытки SQL-инъекций (некорректные запросы)
- [ ] XXE-атаки (некорректный XML)
- [ ] Подозрительная активность (множественные 403, brute-force)
- [ ] Изменения критичных настроек
- [ ] Доступ к sensitive данным

**Рекомендуется:**
- [ ] Успешная аутентификация (для аудита)
- [ ] Доступ к файлам (granted/denied)
- [ ] Изменения прав доступа
- [ ] Создание/удаление пользователей
- [ ] Массовые операции с данными

#### Интеграция с мониторингом

**Отправка в ELK Stack**

```php
// config/logging.php
'channels' => [
    'elk' => [
        'driver' => 'monolog',
        'handler' => Monolog\Handler\SocketHandler::class,
        'handler_with' => [
            'connection_string' => 'tcp://logstash.dogovor24.local:5000',
        ],
        'formatter' => Monolog\Formatter\LogstashFormatter::class,
        'formatter_with' => [
            'application_name' => 'explorer-service',
        ],
    ],
],
```

**Алерты в Prometheus/Grafana**

```php
// Экспорт метрик для Prometheus
use Prometheus\CollectorRegistry;
use Prometheus\Storage\InMemory;

class SecurityMetrics
{
    public static function incrementAuthorizationFailures(string $resource): void
    {
        $registry = app(CollectorRegistry::class);

        $counter = $registry->getOrRegisterCounter(
            'security',
            'authorization_failures_total',
            'Total number of authorization failures',
            ['resource']
        );

        $counter->inc([$resource]);
    }
}
```

#### Best Practices

1. **Логируйте security-события** в отдельный канал
2. **Храните логи минимум 90 дней** для аудита
3. **Интегрируйте с SIEM** (ELK, Splunk, Datadog)
4. **Настройте алерты** на критичные события
5. **Используйте structured logging** (JSON format)
6. **Включайте контекст:** user_id, IP, timestamp, URL
7. **Мониторьте аномалии:** множественные 403, brute-force

---

### A10:2021 – Server-Side Request Forgery (SSRF)

**Описание:** SSRF через XXE или небезопасные HTTP-запросы к внутренним ресурсам.

#### Связь с XXE (см. A03.2)

XXE-инъекция может использоваться для SSRF:

```xml
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "http://internal-api.dogovor24.local/admin/users">
]>
<signature>&xxe;</signature>
```

**Защита:** Отключение внешних сущностей (см. раздел A03.2 XXE Injection).

#### Безопасная работа с внешними HTTP-запросами

```php
// ❌ Небезопасно: пользователь контролирует URL
public function fetchData(Request $request)
{
    $url = $request->input('url');

    // Может быть http://internal-api.local/secrets
    $response = Http::get($url);

    return $response->json();
}

// ✅ Безопасно: whitelist доменов
public function fetchData(Request $request)
{
    $url = $request->input('url');

    // Валидация URL
    if (!$this->isAllowedDomain($url)) {
        abort(400, 'Invalid domain');
    }

    // Timeout и запрет редиректов
    $response = Http::timeout(5)
        ->withOptions([
            'allow_redirects' => false,
            'verify' => true,
        ])
        ->get($url);

    return $response->json();
}

private function isAllowedDomain(string $url): bool
{
    $allowedDomains = [
        'api.external-service.com',
        'cdn.trusted-provider.com',
    ];

    $parsedUrl = parse_url($url);

    if (!$parsedUrl || !isset($parsedUrl['host'])) {
        return false;
    }

    return in_array($parsedUrl['host'], $allowedDomains);
}
```

#### Best Practices

1. **Whitelist внешних доменов**
2. **Отключите редиректы** в HTTP клиенте
3. **Используйте timeouts** для внешних запросов
4. **Блокируйте private IP ranges** (10.0.0.0/8, 192.168.0.0/16)
5. **Отключайте XXE** в XML парсерах

---

## Laravel Security Best Practices

### Eloquent ORM Security

#### Mass Assignment Protection

```php
// ❌ Уязвимо к mass assignment
class User extends Model
{
    // Нет защиты
}

// Атака:
User::create($request->all()); // Может установить is_admin = 1

// ✅ Безопасно: используйте $fillable
class User extends Model
{
    protected $fillable = [
        'name',
        'email',
        'password',
    ];

    // is_admin НЕ в fillable = защищено
}

// ✅ Альтернатива: $guarded
class User extends Model
{
    protected $guarded = [
        'id',
        'is_admin',
        'email_verified_at',
    ];
}
```

#### Query Scopes для изоляции данных

```php
// Автоматическая фильтрация по workspace
class File extends Model
{
    // ✅ Global Scope для multi-tenancy
    protected static function booted()
    {
        static::addGlobalScope('workspace', function (Builder $query) {
            if (auth()->check()) {
                $query->where('workspace_id', auth()->user()->current_workspace_id);
            }
        });
    }
}

// Все запросы автоматически фильтруются:
File::all(); // SELECT * FROM files WHERE workspace_id = 1

// Отключение scope (только для admin):
File::withoutGlobalScope('workspace')->get();
```

#### Soft Deletes для sensitive data

```php
class File extends Model
{
    use SoftDeletes;

    // ✅ Удаленные файлы сохраняются для аудита
    protected $dates = ['deleted_at'];
}

// Удаление (soft delete)
$file->delete(); // Устанавливает deleted_at

// Восстановление
$file->restore();

// Force delete (только для admin)
$file->forceDelete();
```

---

### Input Validation & Sanitization

#### Form Requests

```php
// ✅ Централизованная валидация
class StoreFileRequest extends FormRequest
{
    public function authorize(): bool
    {
        // Проверка прав на создание файла
        return $this->user()->can('create', File::class);
    }

    public function rules(): array
    {
        return [
            'name' => 'required|string|max:255',
            'file' => 'required|file|mimes:pdf,docx|max:10240',
            'description' => 'nullable|string|max:1000',
            'tags' => 'nullable|array',
            'tags.*' => 'string|max:50',
        ];
    }

    public function messages(): array
    {
        return [
            'file.mimes' => 'Only PDF and DOCX files are allowed',
            'file.max' => 'File size must not exceed 10MB',
        ];
    }
}
```

#### Custom Validation Rules

```php
// app/Rules/NotSuspiciousFilename.php
namespace App\Rules;

use Illuminate\Contracts\Validation\Rule;

class NotSuspiciousFilename implements Rule
{
    public function passes($attribute, $value): bool
    {
        // Проверка на подозрительные паттерны
        $suspicious = [
            '../',
            '..\\',
            '<script',
            'javascript:',
            'data:text/html',
        ];

        foreach ($suspicious as $pattern) {
            if (stripos($value, $pattern) !== false) {
                return false;
            }
        }

        return true;
    }

    public function message(): string
    {
        return 'The :attribute contains suspicious content';
    }
}

// Использование
public function rules(): array
{
    return [
        'filename' => ['required', 'string', new NotSuspiciousFilename],
    ];
}
```

#### XSS Prevention в Blade

```php
// ✅ Auto-escaping (безопасно)
<h1>{{ $user->name }}</h1>
// Output: &lt;script&gt;alert('XSS')&lt;/script&gt;

// ❌ No escaping (XSS уязвимость)
<div>{!! $user->bio !!}</div>
// Output: <script>alert('XSS')</script>

// ✅ Безопасный HTML (с санитизацией)
<div>{!! Purifier::clean($user->bio) !!}</div>

// Установка HTML Purifier
composer require mews/purifier
```

---

### Authentication & Authorization

#### Laravel Policies для IDOR защиты

См. подробный пример в разделе [A01: IDOR](#a012021--broken-access-control-idor).

```php
// Регистрация Policy
// app/Providers/AuthServiceProvider.php
protected $policies = [
    File::class => FilePolicy::class,
];

// Использование в контроллере
$this->authorize('download', $file);

// Использование в Blade
@can('download', $file)
    <a href="{{ route('files.download', $file) }}">Download</a>
@endcan
```

#### API Token Security (Sanctum)

```php
// ✅ Используйте Sanctum для API authentication
// config/sanctum.php
'expiration' => 60 * 24, // 24 часа

// Создание токена с ограниченными правами
$token = $user->createToken('mobile-app', ['files:read'])->plainTextToken;

// Проверка abilities в контроллере
if ($request->user()->tokenCan('files:read')) {
    return File::all();
}

// Ревокация токенов
$user->tokens()->delete(); // Удалить все токены
$user->currentAccessToken()->delete(); // Удалить текущий токен
```

---

### Секреты и конфигурация

#### .env vs .env.example

```bash
# ❌ .env.example - НЕ коммитить реальные секреты!
APP_KEY=
DB_PASSWORD=
FILE_ENCRYPTION_KEY=

# Инструкции для генерации
# php artisan key:generate
# Generate FILE_ENCRYPTION_KEY: php artisan key:generate --show

# ✅ .env (добавлен в .gitignore)
APP_KEY=base64:RealGeneratedKeyHere
DB_PASSWORD=SecurePassword123!
FILE_ENCRYPTION_KEY=base64:AnotherRealKey
```

#### Ротация ключей

```bash
# Генерация нового APP_KEY
php artisan key:generate

# ⚠️ WARNING: Это инвалидирует все зашифрованные данные!
# Перед ротацией необходимо:
# 1. Расшифровать существующие данные старым ключом
# 2. Установить новый ключ
# 3. Зашифровать данные новым ключом
```

---

## Code Review Guidelines

### Security Code Review Checklist

Используйте этот чек-лист для каждого pull request:

#### SQL & Database
- [ ] Нет прямых SQL запросов с конкатенацией user input
- [ ] Используется Eloquent ORM или Query Builder с параметризацией
- [ ] Валидация UUID/ID параметров
- [ ] Нет `DB::raw()` с user input

#### Input Validation
- [ ] Все user input валидируется через Form Requests
- [ ] Используются whitelist правила валидации
- [ ] Массивы валидируются с `array.*` правилами
- [ ] Custom validation rules для сложных случаев

#### Authorization
- [ ] Проверка прав доступа через `$this->authorize()` или middleware
- [ ] Laravel Policies для всех моделей с доступом
- [ ] Нет прямого доступа к ресурсам по ID без проверки
- [ ] Global Scopes для multi-tenancy

#### File Upload
- [ ] MIME-type validation (whitelist)
- [ ] Проверка размера файла
- [ ] Безопасное имя файла (UUID, sanitized)
- [ ] Хранение вне webroot
- [ ] Content-Disposition: attachment при скачивании

#### Secrets & Configuration
- [ ] Нет hardcoded секретов, ключей, паролей в коде
- [ ] Секреты хранятся в `.env`
- [ ] `.env.example` не содержит реальных ключей
- [ ] Нет API ключей в frontend коде

#### Dependencies
- [ ] Новые зависимости проверены на уязвимости (`composer audit`)
- [ ] Используются актуальные версии библиотек
- [ ] `composer.lock` обновлен и закоммичен

#### Security Logging
- [ ] Security-критичные действия логируются
- [ ] Отказы в авторизации логируются
- [ ] Подозрительная активность логируется
- [ ] Логи содержат контекст (user_id, IP, timestamp)

#### XML/JSON Parsing
- [ ] XML парсинг с `libxml_disable_entity_loader(true)`
- [ ] JSON валидация перед декодированием
- [ ] Нет direct eval/exec пользовательских данных

#### Cryptography
- [ ] Используется `bcrypt()` или `Hash::make()` для паролей
- [ ] НЕ используется `crypt()` с static salt
- [ ] НЕ используется `md5()`, `sha1()` для паролей
- [ ] Laravel Encryption для sensitive данных

#### Output Escaping
- [ ] Blade templates используют `{{ }}` (auto-escape)
- [ ] `{!! !!}` используется только с sanitized данными
- [ ] API responses не содержат sensitive данных

---

### Процесс Security Review

#### Роли

**Код-автор:**
- Проводит self-review перед созданием PR
- Запускает security checklist
- Добавляет security-related комментарии в PR description

**Ревьюер:**
- Проверяет PR по security checklist
- Запрашивает исправления для уязвимостей
- Одобряет PR только после устранения проблем

**Security Champion:**
- Ревьюит security-критичные изменения
- Проводит security training для команды
- Эскалирует критичные находки

#### Обязательные Approvals

```yaml
# .github/CODEOWNERS (GitHub) или аналог для GitLab
# Security-критичные файлы требуют review от Security Champion

# Authentication & Authorization
app/Policies/* @security-champion
app/Http/Middleware/Auth* @security-champion

# File Upload
app/Http/Requests/*FileRequest.php @security-champion

# Deployment & Configuration
deploy.sh @security-champion
.env.example @security-champion
composer.json @security-champion
```

#### Эскалация проблем безопасности

**Severity levels:**

- **CRITICAL** (SQL Injection, RCE, Auth Bypass):
  - Блокировать PR немедленно
  - Эскалация к Security Champion и CTO
  - Исправление до мерджа (не откладывать)

- **HIGH** (IDOR, XSS, Hardcoded secrets):
  - Блокировать PR
  - Исправление в этом же PR

- **MEDIUM** (Слабая валидация, отсутствие логирования):
  - Создать отдельную задачу для исправления
  - Можно мерджить с approvals

- **LOW** (Code style, minor improvements):
  - Рекомендация для будущих PR

---

### Интеграция с AI-код-ревью системой

#### Использование AI-код-ревью для автоматического обнаружения

**Workflow:**

1. **Разработчик создает PR**
2. **CI/CD автоматически запускает AI-код-ревью**
3. **AI анализирует изменения** и находит потенциальные уязвимости
4. **AI оставляет комментарии** в PR с найденными проблемами
5. **Ручной ревьюер проверяет** результаты AI и принимает решение

#### Интерпретация результатов AI-анализа

**AI нашел SQL Injection:**

```php
// AI Comment:
// ⚠️ Potential SQL Injection
// Line 42: DB::raw() с конкатенацией user input

DB::select("SELECT * FROM files WHERE uuid IN ('" . implode("','", $uuids) . "')");
```

**Действия ревьюера:**
1. Подтвердить уязвимость
2. Запросить рефакторинг на Eloquent/Query Builder
3. Проверить валидацию входных данных

**AI нашел IDOR:**

```php
// AI Comment:
// ⚠️ Missing Authorization Check
// Line 28: Доступ к File без проверки прав

public function download(File $file) {
    return $this->service->download($file);
}
```

**Действия ревьюера:**
1. Проверить наличие Policy для File
2. Запросить добавление `$this->authorize('download', $file)`
3. Проверить middleware на роуте

#### Дополнение ручного ревью автоматическим

**Что AI делает хорошо:**
- Обнаружение SQL Injection patterns
- Поиск hardcoded секретов
- Проверка устаревших функций (md5, crypt)
- Поиск XSS в Blade templates

**Что требует ручного ревью:**
- Бизнес-логика авторизации
- Contextual security (является ли данный случай уязвимостью)
- Архитектурные решения
- False positives фильтрация

**Hybrid подход (рекомендуется):**
1. AI-код-ревью для первичного скрининга
2. Ручной ревью для подтверждения и контекста
3. Security Champion для критичных изменений

---

### Примеры из реальных PR

#### Пример 1: Исправление SQL Injection

**До (уязвимо):**

```php
// PrepareDownloadMultipleJob.php
$files = DB::select("
    SELECT * FROM files
    WHERE uuid IN ('" . implode("','", $this->data['file_uuids']) . "')
");
```

**После (безопасно):**

```php
// PrepareDownloadMultipleJob.php
$files = File::query()
    ->whereIn('uuid', $this->data['file_uuids'])
    ->where('workspace_id', $this->workspaceId)
    ->get();
```

**PR Description:**
```markdown
## Security Fix: SQL Injection in PrepareDownloadMultipleJob

### Issue
CRITICAL SQL Injection vulnerability in PrepareDownloadMultipleJob due to direct concatenation of user input.

### Changes
- Replaced DB::raw() with Eloquent whereIn()
- Added UUID validation in PrepareDownloadMultipleRequest

### Security Checklist
- [x] SQL queries параметризованы
- [x] User input валидируется
- [x] Добавлены unit tests
- [x] Прошел AI-код-ревью

### Testing
- Unit tests для валидации
- Manual testing с malicious payloads
```

#### Пример 2: Исправление IDOR

**До (уязвимо):**

```php
public function download(string $uuid)
{
    return $this->uuidFileService->download($uuid);
}
```

**После (безопасно):**

```php
public function download(File $file)
{
    $this->authorize('download', $file);

    SecurityLogger::logFileAccessAttempt($file->uuid, true);

    return $this->uuidFileService->download($file);
}
```

**Added FilePolicy:**

```php
class FilePolicy
{
    public function download(User $user, File $file): bool
    {
        return $file->workspace_id === $user->current_workspace_id
            && ($file->user_id === $user->id || $file->sharedUsers->contains($user));
    }
}
```

---

## Quick Wins & Action Items

### Немедленные действия (можно сделать сегодня)

#### 1. Добавить `composer audit` в CI/CD

```yaml
# .gitlab-ci.yml
security-audit:
  stage: test
  script:
    - composer install
    - composer audit
  only:
    - merge_requests
    - main
```

**Время:** 15 минут
**Приоритет:** CRITICAL
**Ответственный:** DevOps

---

#### 2. Изменить `deploy.sh`

```bash
# Заменить
composer update

# На
composer install --no-dev --no-interaction --prefer-dist --optimize-autoloader
```

**Время:** 5 минут
**Приоритет:** CRITICAL
**Ответственный:** DevOps

---

#### 3. Очистить `.env.example` от реальных ключей

```bash
# Заменить
FILE_ENCRYPTION_KEY=w9VDvenKYpdcRAfrAh0IKSmRJW1JYii4

# На
FILE_ENCRYPTION_KEY=
```

**Время:** 5 минут
**Приоритет:** CRITICAL
**Ответственный:** Backend Lead

---

#### 4. Добавить логирование `AuthorizationException`

См. раздел [A09: Security Logging](#a092021--security-logging-and-monitoring-failures).

**Время:** 30 минут
**Приоритет:** HIGH
**Ответственный:** Backend Developer

---

#### 5. Установить минимум 1 approval для всех PR

**GitLab:**
```
Settings → Repository → Merge Requests → Merge request approvals
Approvals required: 1
```

**Время:** 2 минуты
**Приоритет:** MEDIUM
**Ответственный:** CTO

---

### Краткосрочные улучшения (1-2 недели)

#### 1. Внедрить Laravel Policies для контроллеров доступа к файлам

**Задачи:**
- Создать `FilePolicy` с методами: `view`, `download`, `update`, `delete`
- Зарегистрировать Policy в `AuthServiceProvider`
- Добавить `$this->authorize()` во все контроллеры
- Покрыть тестами

**Время:** 8-12 часов
**Приоритет:** CRITICAL
**Ответственный:** Backend Team

---

#### 2. Обновить уязвимые зависимости

```bash
composer require lcobucci/jwt:^4.3
composer require guzzlehttp/guzzle:^7.5
composer update
php artisan test  # Прогнать тесты
```

**Время:** 4-6 часов (с тестированием)
**Приоритет:** CRITICAL
**Ответственный:** Backend Lead

---

#### 3. Добавить MIME-type validation для загрузки файлов

См. раздел [A04: File Upload Security](#a042-unrestricted-file-upload).

**Время:** 4 часа
**Приоритет:** HIGH
**Ответственный:** Backend Developer

---

#### 4. Рефакторинг SQL-запросов на Eloquent/Query Builder

**Найти все использования:**
```bash
grep -r "DB::raw\|DB::select" app/
```

**Заменить на Eloquent/Query Builder**

**Время:** 12-16 часов
**Приоритет:** CRITICAL
**Ответственный:** Backend Team

---

### Долгосрочные улучшения (1-3 месяца)

#### 1. Внедрить PHPStan/Psalm для статического анализа

```bash
composer require --dev phpstan/phpstan
composer require --dev vimeo/psalm

# phpstan.neon
parameters:
    level: 5
    paths:
        - app

# Запуск
vendor/bin/phpstan analyse
vendor/bin/psalm
```

**Время:** 2-3 недели (настройка + исправление найденных проблем)
**Приоритет:** MEDIUM
**Ответственный:** Backend Lead

---

#### 2. Настроить автоматические линтеры в CI

```bash
composer require --dev squizlabs/php_codesniffer
composer require --dev friendsofphp/php-cs-fixer

# .gitlab-ci.yml
code-style:
  stage: test
  script:
    - vendor/bin/phpcs
    - vendor/bin/php-cs-fixer fix --dry-run --diff
```

**Время:** 1 неделя
**Приоритет:** MEDIUM
**Ответственный:** DevOps + Backend Lead

---

#### 3. Регулярные Security Code Review сессии

**План:**
- Weekly security review meeting (1 час)
- Разбор найденных уязвимостей
- Обучение команды
- Обновление security checklist

**Время:** Постоянная активность
**Приоритет:** HIGH
**Ответственный:** Security Champion (Сергей)

---

#### 4. Обучение команды OWASP Top 10

**Программа:**
- Презентация OWASP Top 10 (2 часа)
- Практические примеры из аудита explorer-service (2 часа)
- Hands-on workshop: исправление уязвимостей (4 часа)
- Quizкс для проверки знаний

**Время:** 8 часов (разбито на 4 сессии)
**Приоритет:** HIGH
**Ответственный:** Сергей (консультант)

---

## Резюме

Это руководство покрывает 7 категорий OWASP Top 10, найденных в аудите explorer-service:

1. **A01: Broken Access Control (IDOR)** - используйте Laravel Policies
2. **A02: Cryptographic Failures** - используйте Laravel Encryption, не crypt()
3. **A03: Injection** - Eloquent ORM, отключайте XXE
4. **A04: Insecure Design** - stream-based processing, MIME validation
5. **A06: Vulnerable Components** - composer audit, composer install в deploy
6. **A09: Logging Failures** - логируйте AuthorizationException
7. **A10: SSRF/XXE** - whitelist доменов, отключайте внешние сущности

**Критичные Quick Wins (сегодня):**
- ✅ Добавить `composer audit` в CI/CD
- ✅ Заменить `composer update` → `composer install` в deploy.sh
- ✅ Очистить `.env.example` от ключей
- ✅ Логировать `AuthorizationException`
- ✅ Установить 1+ approvals для PR

**Приоритеты (1-2 недели):**
- 🔥 Внедрить Laravel Policies для файлов
- 🔥 Обновить уязвимые зависимости
- 🔥 Рефакторинг SQL на Eloquent
- 🔥 MIME-type validation

---

**Вопросы и обратная связь:**
Сергей Соболев - Технический консультант по безопасности
Telegram: @username | Email: sergei@example.com
